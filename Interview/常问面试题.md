# 常问面试题

### 一、`SQL`的生命周期

- 应用服务器与数据服务器建立一个连接。
- 数据进程拿到请求的`sql`。
- 解析并生成执行计划，执行。
- 读取数据到内存并进行逻辑处理。
- 通过建立的连接`步骤一的连接`，发送到客户端。
- 关掉连接，释放资源。

<br>

<br>

### 二、事务的四大特性：`ACID`

- ##### 数据库支持事务操作要具备的四个特性：

  - 原子性`Atomicity`：事务包含的所有操作要么全部成功`必须完全运用到数据库`，要么全部回滚失败`不能对数据库有任何影响`。
  - 一致性`Consistency`：事务必须使数据库从一个一致性状态换到另一个一致性状态，也就是说一个事务执行前和执行后都必须处于一致性状态。
  - 隔离性`Isolation`：多个用户并发访问数据库时，单个事务的操作不能相互干扰，所以多个并发事务之间要相互隔离。
    - `MySQL`数据库提供的四种隔离级别：
      - `Serializable` (串行化)：可避免脏读、不可重复读、幻读的发生；
      - `Repeatable read` (可重复读)：可避免脏读、不可重复读的发生；
      - `Read committed` (读已提交)：可避免脏读的发生；
      - `Read uncommitted` (读未提交)：最低级别，任何情况都无法保证。
  - 持久性`Durability`：事务一旦被提交，对数据库的数据改变是永久性的，数据库系统遇到故障的情况下也不会丢失提交事务的操作。

<br>

- ##### 数据事务并发造成的问题：

  - 脏读：一个事务处理过程中读取了另一个未提交的事务中的数据。
  - 不可重复读：一个事务范围内多次查询却返回了不同的数据值，在查询间隔被另一个事务修改并提交了`读取了另一条已经提交的事务`。
  - 虚读（幻读）：幻读是事务非独立执行时发生的一种现象`读取了另一条已经提交的事务`。

<br>

<br>

### 三、`Redis`数据类型

- `String` `字符串、整数或者浮点数` 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增或者自减操作。
- `List` `列表` 从两端压入或者弹出元素；对单个或者多个元素进行修剪，只保留一个范围内的元素。
- `Set` `无序集合` 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素。
- `Zset` `有序集合` 添加、获取、删除元素；根据分值范围或者成员来获取元素；计算一个键的排名。
- `Hash` `包含键值对的无序散列表` 添加、获取、移除单个键值对获取所有键值对；检查某个键是否存在。

<br>

<br>

### 四、Redis的三种集群模式

- 主从模式
- 哨兵模式
- `Cluster`集群模式

<br>

<br>

### 五、`Strin`、`StringBuffer`与`StringBuilder`的区别

![](https://github.com/im-dashan/Notes/raw/main/面试笔记/Images/常问面试题/2021-08-20_190601.png)

- `String`可以空赋值，`StringBuffer`和`StringBuilder`不行，报错；
- 操作少量的数据用`String`；
- 多线程操作字符串缓冲区下操作大量数据`StringBuffer`；
- 单线程操作字符串缓冲区下操作大量数据`StringBuilder`。
  - 底层实现，`StringBuffer`比`StringBuilder`多了`Synchronized`修饰符。

<br>

<br>

### 六、在Java中如何跳出当前的多重嵌套循环

- 可以在外层循环语句前定义一个标号，然后在内层循环体的代码中使用带有标号的`break`语句，即可跳出外层循环

```java
public static void main(String[] args) {
        public static void method1 () {
            ok:
            for (int i = 0; i < 10; i++) {
                for (int j = 0; j < 10; j++) {
                    System.out.println("i=" + i + ",j=" + j);
                    if (j == 5) {
                        break ok;//跳到循环外的ok处，即终止整个循环
                    }
                }
            }
        }
    }
```

<br>

<br>

### 七、`int`和`Integer`有什么区别

- Java提供两种不同类型：
  - 基本数据类型：`boolean`，`char`，`byte`，`short`，`int`，`long`，`float`，`double`；
  - 封装类类型：`Boolean`，`Character`，`Byte`，`Short`，`Integer`，`Long`，`Float`，`Double`。
  - 引用数据类型：`数组`、`类`、`接口`。

- `Int`是`java`的原始数据类型，`Integer`是`java`为`int`提供的封装  `int的包装类就是Integer`。

```java
// 装箱
Integer a = 10;
// 拆箱
int b = a;
```

<br>

<br>

### 八、数组`Array`和列表`ArrayList`的区别

- ##### 不同点：
  - `Array是数组` `ArrayList是一个集合`
  - 存储内容比较：`Array`可以包含基本类型和对象类型，`ArrayList`却只能包含对象类型，`Array`数组在存放的时候必须是同种类型的元素，`ArrayList`就不一定了；
  - 空间大小比较：`Array`数组空间大小是固定的，需要提前确定合适的空间大小，`ArrayList`的空间是动态增长的，而且每次添加新的元素的时候都会检查内部数组的空间是否足够；
  - 方法上的比较：`ArrayList`方法比`Array`更多样化，支持迭代器操作
    - ArrayList提供的方法和特性：`addAll()`，`removeAll()`，`iterator()`...

- ##### 适用场景：

  - 数据长度不变时尽量使用`Array`；
  - 当长度不固定时使用`ArrayList`，如果需要频繁增加数据时，可预设`ArrayList`的长度来减少复制数组的损耗；
  - 需要对元素进行频繁的移动或删除，或者是处理超大量的数据时`ArrayList`效率很低，可以考虑选择`LinkedList`。

<br>

<br>

### 九、什么是值传递和引用传递

- 一般`java`内的传递都是值传递

- 值传递：值传递是对基本型变量而言的，传递的是一个变量的副本，改变副本不影响原变量；
- 引用传递：引用传递一般是对对象(引用)型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，所以引用对象进行操作时会改变原对象。

<br>

<br>

### 十、`Lamda`表达式的优缺点

- 优点：
  - 简洁
  - 非常容易并行计算
  - 可能代表未来的编程趋势
- 缺点：
  - 若不用并行计算，很多时候计算速度没有比传统的`for`循环快
  - 不容易调试
  - 若其他程序员没有学过`lambda`表达式，代码不容易让其他语言的程序员看懂

<br>

<br>

### 八、`final`，`finally`与`finalize`的区别

- `final`为常量关键字，而`finally`为异常关键字，`finalize`为`object`自带方法名
  - `final`：
    - `final`在`Java`中代表不可改变的，可用来修饰`类`，`方法`，`变量`;
    - `final`修饰的变量必须在声明时赋值，且不能再改变。
  - `finally`：
    - `finally`关键字用在异常处理中，用于处理异常后的清理工作；
    - `finally`实际中一般用于关闭文件流，释放资源等操作。
  - `finalize()`：
    - `finalize()`是`Object`里面的一个方法，当一个堆空间中的对象没有被栈空间变量指向的时候，这个对象会等待被`java`回收；
    - 垃圾回收机器，也叫`GC`：
      - 当对象不再被程序所使用的时候，垃圾回收器将会将其回收
      - 垃圾回收是在后台运行的，我们无法命令垃圾回收器马上回收资源，但是我们可以告诉可以尽快回收资源`System.gc()`和`Runtime.getRuntime().gc()`
      - 垃圾回收器在回收某个对象的时候，首先会调用该对象的`finalize()`方法
      - `GC`主要针对堆内存

<br>

<br>

### 九、`Java`中的方法重写`Overriding`和方法重载`Overloading`

- ##### 方法重写`Overriding`：

  - 重写的方法的方法名、参数个数、参数的类型要和父类的方法必须完全相同，这样定义的方法称作子类重写的方法`重写`；
  - 重写的注意事项：
    1. 参数列表必须完全与被重写的方法完全相同
    2. 参数的返回值必须一致
    3. 访问权限不能比父类中被重写方法的访问权限低
    4. 声明为`final`的方法不能被重写
    5. 声明为`static`的方法也不能被重写，但是可以被再次声明
    6. 如果子类和父类是在同一个包，那么子类可以重写父类的所有的方法
    7. `private`，因为私有的都继承不了，那就重写不了
    8. 构造方法也不能被重写

- ##### 方法重载`overloading`：

  - 在一个类中，方法名相同、参数不同、返回值可以相同也可以不同。
    每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
  - 重载的注意事项：
    1. 方法名必须相同
    2. 方法的参数必须不同
    3. 返回类型可以相同也可以不同
    4. 参数的个数不同
    5. 参数的个数相同，但是参数列表中对应的某个参数的类型不同

<br>

<br>

### 十、重载`Overload`和重写`Override`的区别

- ##### 重写`Override`：

  - `Override`是重写的一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写`重新实现`父类中的方法；
  - 重写`覆盖`的规则：
    1. 重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载；
    2. 重写方法的访问修饰符一定要大于被重写方法的访问修饰符`public`>`protected`>`default`>`private`；
    3. 重写的方法的返回值必须和被重写的方法的返回一致；
    4. 重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类；
    5. 被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写；
    6. 静态方法不能被重写为非静态的方法`会编译出错`。


![](https://github.com/im-dashan/Notes/raw/main/面试笔记/Images/常问面试题/2021-08-23_193127.png)

- ##### 重载`Overload`：

  - `Overload`是重载，一般是用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同；
  - 重载的规则：
    1. 在使用重载时只能通过相同的方法名、不同的参数形式实现。不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序`参数类型必须不一样`；
    2. 不能通过访问权限、返回类型、抛出的异常进行重载；
    3. 方法的异常类型和数目不会对重载造成影响。

<br>

<br>

### 十一、`Java`是否支持多继承

- `java`中的类是单继承的，不支持多继承；
  - 即一个类只有一个父类。
- `java`中的接口可以间接实现多继承，即一个子接口可以有多个父接口；
  - 接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能；
  - 接口的多继承不存在父接口中有同名方法的问题，因为接口中都是抽象方法，没有具体实现，不存在冲突，但是如果定义了相同的常量，则不能使用，会提示不明确的变量，必须通过接口名显示调用。

<br>

<br>

### 十二、`ArrayList`和`LinkedList`的区别

- `ArrayList`的实现是基于`数组`来实现的，`LinkedList`的基于`双向链表`来实现。这两个数据结构的逻辑关系是不一样，当然物理存储的方式也会是不一样；
- `LinkedList`比`ArrayList`更占内存，因为`LinkedList`的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；
- 对于随机访问，`ArrayList`要优于`LinkedList`；
- 对于插入和删除操作，`LinkedList`优于`ArrayList`。

<br>

<br>

### 十三、`HashMap`和`Hashtable`的区别

- ##### 是否线程安全

  - `HashMap`不是线程安全的，`HashTable`是线程安全的；
    - 【`HashTable`内部的方法基本都使用了synchronized关键字修饰】
  - 注意：现在`HashTable`在我们的开发中很少很少使用。如果你要保证线程安全，推荐使用`ConcurrentHashMap`。

- ##### 效率

  - 因为线程安全的问题，`HashMap`要比`HashTable`的效率高一点。

- ##### 对于`Null Key`和`Null Value`的支持

  - `HashMap`中，`null`可以作为`key`，但是这样的`key`只能有一个；可以有一个或者多个键对应的`value`为`null`；
  - `HashTable`中不支持`key`为`null`，如果`put`使用`null`，那么就会抛出`NullPointerException`异常。

- ##### 初始容量和每次扩充容量的大小不同

  - `HashMap`创建的时候如果不指定容量大小，初始容量大小为`16`，之后每次扩充，容量变为原来的`2倍`；
  - `HashTable`创建的时候如果不指定容量大小，初始容量大小为`11`，之后每次扩充，容量会变为`2n + 1`；
  - `HashTable`创建时如果给定了容量初始值，那么`Hashtable`会直接使用你给定的大小。

- ##### 底层数据结构

  - `JDK1.8`以后的`HashMap`在解决哈希冲突时有了较大的变化，当链表长度大于阈值`默认为8`时，将链表转化为红黑树，以减少搜索时间；
  - `Hashtable`没有这样的机制。

<br>

<br>

### 十四、`多线程`如何保证线程安全

- ##### 线程安全等级`由强到弱排序`

  - 不可变
    - 在`java`语言中，`不可变`的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。如`final`关键字修饰的数据不可修改，可靠性最高；
  - 绝对线程安全
    - 绝对的线程安全完全满足`Brian GoetZ`给出的线程安全的定义，这个定义其实是很严格的，一个类要达到不管运行时环境如何，调用者都不需要任何额外的同步措施通常需要付出很大的代价；
  - 相对线程安全
    - 相对线程安全就是我们通常意义上所讲的一个类是”线程安全“的；
    - 它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性；
    - 在`java`语言中，大部分的线程安全类都属于相对线程安全的，例如`Vector`、`HashTable`、`Collections`的`synchronizedCollection()方法`；
  - 线程兼容
    - 线程兼容就是我们通常意义上所讲的一个类不是线程安全的；
    - 线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境下可以安全地使用；
    - `Java API`中大部分的类都是属于线程兼容的。如与前面的`Vector`和`HashTable`相对应的集合类`ArrayList`和`HashMap`等；
  - 线程对立
    - 线程对立是指无论调用端是否采取了同步错误，都无法在多线程环境中并发使用的代码；
    - 由于`java`语言天生就具有多线程特性，线程对立这种排斥多线程的代码是很少出现的；
    - 一个线程对立的例子是`Thread`类的`supend()`和`resume()`方法`已被废弃`

- ##### 线程安全的实现方法

  -  保证线程安全以是否需要同步手段分类，分为同步方案和无需同步方案
  -  ![](https://github.com/im-dashan/Notes/raw/main/面试笔记/Images/常问面试题/2021-08-25_170651.png)
  -  同步方案
     -  互斥同步
        -  互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。
        -  在`java`中，最基本的互斥同步手段就是`synchronized`关键字，`synchronized`关键字编译之后，会在同步块的前后分别形成`monitorenter`和`monitorexit`这两个字节码质量，这两个字节码指令都需要一个`reference`类型的参数来指明要锁定和解锁的对象。
        -  此外，`ReentrantLock`也是通过互斥来实现同步。在基本用法上，`ReentrantLock`与`synchronized`很相似，他们都具备一样的线程重入特性。
        -  互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它行加锁。
     -  非阻塞同步 
        -  随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步；
        -  非阻塞的实现`CAS` `compareandswap` `：` `CAS`指令需要有3个操作数，分别是内存地址《在java中理解为变量的内存地址，用V表示》、旧的预期值《用A表示》和新值《用B表示》。`CAS`指令执行时，`CAS`指令指令时，当且仅当`V`处的值符合旧预期值`A`时，处理器用`B`更新`V`处的值，否则它就不执行更新，但是无论是否更新了`V`处的值，都会返回`V`的旧值，上述的处理过程是一个原子操作。
  -  无需同步方案
     -  **要保证线程安全，并不是一定就要进行同步**，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性，因此会有一些代码天生就是线程安全的。
        -  可重入代码
           -  可重入代码`ReentrantCode`也称为纯代码`Pure Code`，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的；
           -  可重入代码的特点是不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数中传入、不调用非可重入的方法等；
           -  类比：`synchronized`拥有锁重入的功能，也就是在使用`synchronized`时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁。
        -  线程本地存储
           -  如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题；
           -  符合这种特点的应用并不少见，大部分使用消费队列的架构模式`如“生产者-消费者”模式`都会将产品的消费过程尽量在一个线程中消费完。`其中最重要的一个应用实例就是经典的` `Web`交互模型中的《一个请求对应一个服务器线程`Thread-per-Request`的处理方式》，这种处理方式的广泛应用使得很多`Web`服务器应用都可以使用线程本地存储来解决线程安全问题。

<br>

<br>

### 十五、同步方法和同步代码块的区别是什么

- 同步方法直接在方法上加`synchronized`实现加锁，同步方法锁的范围比较大；

  - 同步方法使用`synchronized`修饰方法，在调用该方法前，需要获得内置锁`java每个对象都有一个内置锁`，否则就处于阻塞状态；

  - ```java
    public synchronized void save(){
            //内容
        	}
    ```

    

- 同步代码块则在方法内部加锁，同步代码块范围要小点；

  - 同步代码块使用`synchronized(object){}`进行修饰，在调用该代码块时，需要获得内置锁，否则就处于阻塞状态；

  - ```java
    synchronized(object){
            //内容
            }
    ```

  - 同步的范围越大，性能就越差；

  - 一般需要加锁进行同步的时候，范围越小越好，这样性能更好。

<br>

<br>

### 十六、线程池有什么优势

- ##### 线程池作用：

  - 线程池做的工作主要是控制运行线程的数量，处理过程中将任务放入队列，然后线程创建后启动这些任务，如果线程数量超过了最大线程数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。

- ##### 特点：

  - 线程复用，控制最大并发数，管理线程。

- ##### 好处：

  - 降低资源消耗，通过重复利用已创建的线程，降低线程创建和销毁造成的资源消耗；
  - 提交响应速度，当任务到达时，任务可以不需要等待线程创建就能执行；
  - 提高线程的可管理性。线程是稀缺资源，如果无限的创建，不仅会消耗系统的资源，还会降低系统的稳定性，使用线程池可以统一的分配，调优和监控。

<br>

<br>

### 十七、什么是[反射](https://github.com/im-dashan/Notes/blob/main/学习笔记/反射.md)机制

- ##### 什么是反射机制？

  - 在程序运行状态中，对于任意一个类或对象，都能够获取到这个类的所有属性和方法（包括私有属性和方法），这种动态获取信息以及动态调用对象方法的功能就称为反射机制；
  - 简单来讲，通过反射，类对我们是完全透明的，想要获取任何东西都可以。

- ##### 反射的优点

  - 可以在程序运行过程中，操作这些对象；
  - 可以解耦，提高程序的可扩展性。

- ##### 获取`Class`对象的三种方式

  - 【`Source`源代码阶段】 `Class.forName(“全类名”);`将字节码文件加载进内存，返回`Class`对象；多用于配置文件，将类名定义在配置文件中，通过读取配置文件加载类；
  - 【`Class`类对象阶段】 `类名.class;`通过类名的属性`Class`获取；多用于参数的传递；
  - 【`Runtime`运行时阶段】`对象.getClass();`此方法是定义在`Objec`类中的方法，因此所有的类都会继承此方法，多用于对象获取字节码的方式。

```java
public class getClass {
        public static void main(String[] args) throws Exception {

            //方式一：Class.forName("全类名");
            Class class1 = Class.forName("zzuli.edu.cn.Person");   //Person自定义实体类
            System.out.println("class1 = " + class1);

            //方式二：类名.class
            Class class2 = Person.class;
            System.out.println("class2 = " + class2);

            //方式三：对象.getClass();
            Person person = new Person();
            Class class3 = person.getClass();
            System.out.println("class3 = " + class3);

            //比较三个对象
            System.out.println(class1 == class2);    //true
            System.out.println(class1 == class3);    //true
        }
    }
```

`运行结果：`

```java
class1 = class zzuli.edu.cn.Person
class2 = class zzuli.edu.cn.Person
class3 = class zzuli.edu.cn.Person
true
true
```

**结论**：同一个字节码文件`*.class`在一次程序运行过程中，只会被加载一次，无论通过哪一种方式获取的`Class`对象都是同一个。

<br>

<br>

### 十八、`JVM`类加载机制分为那五个部分

- `JVM`类加载机制分为五个部分：加载，验证，准备，解析，初始化。

<br>

<br>

### 十九、`IOC`和`AOP`

- `IOC`：控制反转，是一种设计模式。
  - `IOC`的作用：消减计算机程序的耦合度（只能解决程序间的依赖关系）
  - 现有`类A`依赖于`类B`
    - 传统的开发方式：往往是在`类A`中手动通过`new`关键字来`new`一个`B的对象`出来；
    - 使用`IOC`思想的开发方式：不通过`new`关键字来创建对象，而是通过IOC容器(`Spring 框架`) 来帮助我们实例化对象。我们需要哪个对象，直接从`IOC`容器里面过去即可。
- `AOP`：面向切面编程，是一种编程思想。
  - 把散落穿插在各个业务逻辑中非常冗余且不利于维护的代码抽离出来，写成公共方法；
  - 简单地理解，其实`AOP`要做三件事：
    - 在哪里切入，也就是权限校验等非业务操作在哪些业务代码中执行。
    - 在什么时候切入，是业务代码执行前还是执行后。
    - 切入后做什么事，比如做权限校验、日志记录等。
  - `AOP`术语：
    - ![](https://github.com/im-dashan/Notes/raw/main/面试笔记/Images/常问面试题/2021-09-21_173434.png)
  - `AOP`的实现方式：
    - ![](https://github.com/im-dashan/Notes/raw/main/面试笔记/Images/常问面试题/2021-09-21_173747.png)
- `Spring`的`AOP`和`IOC`都是为了解决系统代码耦合度过高的问题。使代码重用度高、易于维护。
- `AOP`和`IOC`并不是`Spring`中特有的，只是`Spring`把他们应用的更灵活方便。

<br>

<br>

### 二十、`MyBatis`中的动态`SQL`是什么

- 动态`sql`就是（在进行`sql`操作的时候）动态的根据属性值（所匹配的条件）来拼接数据库执行的`sql`语句，也就是多次查询或变更操作，根据传入的属性值不同，动态拼接出不同的可执行`sql`。包含判断为空、循环等。

- 实现动态SQL的元素主要有： 
  - \- if 
  - \- choose / when / otherwise 
  - \- trim 
  - \- where 
  - \- set 
  - \- foreach

<br>

<br>

### 二十一、`JAVA`数据结构

<br>

<br>

### 二十二、`JAVA`值传递和引用传递

- C++是有两种传递方式
  - 值传递
  - 引用传递
- JAVA到底是值传递还是引用传递
  - 值传递：方法接收的是调用者的值
    - `JAVA`本质还是值传递的
    - 《Java 核心技术》`Java程序设计语言总是采用按值来调用的`，即方法得到的是所有参数值的一个拷贝。因为传递过来的相当于是一个副本，因此方法只能改变这个副本所对应的值或者对象。
    - 在方法被调用时，实参通过形参把它的内容副本传入方法内部，
      此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，
      都仅仅是对这个副本的操作，不影响原始值的内容。
  - 按引用传递：方法接收的是调用者提供的变量地址
    - 引用传递也就是指向真实内容的地址值，在方法调用时，
      实参的地址通过方法调用被传递给相应的形参，在方法体内，
      形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。

<br>

<br>

### 二十三、`MySQL`索引数据结构

- 数据库索引主要有`Hash`表、二叉树、红黑树、`B-Tree`、`B+Tree`，我们`MySQL`使用的是`B+Tree`
- B+Tree是B-Tree的变种
  - 不同点：
    - 每个节点上限为2d而不是2d+1
    - 内节点不存储data，只存key；节点叶子不存储指针

<br>

<br>

### 二十四、数据库三大范式是什么

- 第一范式（1NF）：列不可在分

  - 每一列属性都是不可再分的属性值，确保每一列的原子性
  - 两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据

- 第二范式（2NF）：属性完全依赖于主键

  - 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键

- 第三范式（3NF）：属性不依赖于其他非主属性，属性直接依赖于主键

  - 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a-->b-->c  属性之间含有这样的关系，是不符合第三范式的。

    比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）

    这样一个表结构，就存在上述关系。 学号--> 所在院校 --> (院校地址，院校电话)

    这样的表结构，我们应该拆开来，如下。

       （学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）

    总结：三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求>性能>表结构。所以不能一味的去追求范式建立数据库。

